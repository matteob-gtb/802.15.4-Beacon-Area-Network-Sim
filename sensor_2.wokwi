/**
   ESP32 + DHT22 Example for Wokwi
   
   https://wokwi.com/arduino/projects/322410731508073042
*/
#include "DHTesp.h"
#include <WiFi.h>
#include <PubSubClient.h>
#include <ArduinoJson.h> 
#include <esp_random.h> 

#define JSON_MSG_BUFFER_SIZE 500 

typedef struct MESSAGE_ANON_STRUCT {
  unsigned short to;
  unsigned short humidity_value;
  unsigned long sequence_number;
} DATA_MESSAGE; 
/*this data message will be transformed into their json equivalent 
before being sent to the PAN coord., it's stored this way to 
consume as little memory as possible in the mote*/

unsigned long global_seq_counter = 0;
unsigned long last_unack_msg = 0;

#define READINGS_QUEUE_SIZE 200
//buffer to wait for a reading, managed as a FIFO queue
//head points to the first available operand
//tail to the first available spot for a new one
DATA_MESSAGE readings_queue[READINGS_QUEUE_SIZE];
unsigned short head = 0,tail = 0,n_readings = 0;
//hardcoded "json" to make it easier to compute their sizes

#define ASSOCIATION_MESSAGE_TYPE 0
/*
#define RTT_ESTIMATION_REQUEST_TYPE 1
#define RTT_ESTIMATION_RESPONSE_TYPE 2
deprecated
*/
#define BEACON_MESSAGE_TYPE 0x1e
#define DATA_MESSAGE_TYPE 0x100 
#define DATA_DOWNLINK_MSG_TYPE 0x101
#define DATA_ACK_MESSAGE 0x200 //same value for uplink/downlink


/*i'm sorry for the weird channel name but some random people were able to publish on the other ones i chose so i used the hash of my
person code*/
#define MQTT_TOPIC "/iot/polimi/c22b520197ff50c6ae38d0536a41a53d17e7e7ed9ece4ed815b74b9459c20238"
#define MQTT_BROKER "broker.hivemq.com"

#define MOTE_ID "10656748-SENS2"

/*assuming a-priori knowledge of the actuators that will receive the data
generated by the sensors*/
#define ACTUATOR_1 "10656748-ACT1"
#define ACTUATOR_2 "10656748-ACT2"

/* keep track of the status of the actuators,
send them data only if they are online, i.e. AID of actuator_i != 0*/
unsigned short act_1_aid = 0,act_2_aid = 0;

#define DHT_PIN 15
#define MQTT_PORT 1883
#define LED_PIN 14

//bool RTT_ESTIMATED = false; deprecated
bool associated_to_PAN = false;
bool association_req_sent = false; 

/*"hack" to account for the remote broker's delay*/
bool expecting_beacon,expecting_ACK;

/* the coordinator will assign a unique numeric ID
to identify the mote in the network, to keep string manipulation 
to a minimum for each beacon message */
short AID = -1;

const int SLIDER_PIN = 35;
const int CONNECTED_LED = 2;
/*save when the next beacon will be transmitted*/
unsigned long long next_beacon_time_milli = -1;
unsigned int pan_id = 0; 



WiFiClient wifiClient;
PubSubClient mqttClient(wifiClient);
DHTesp dhtSensor;

/* the queue is not thread safe as it's only accessed by code running on core #1
also i'm pretty sure that the two cores cannot give rise do data races as everything is 
simulated in JS which is single threaded*/

bool get_first(unsigned short * to, unsigned short* measurement, unsigned long* seq){
  if(n_readings == 0) return false;
  *to =  readings_queue[head].to;
  *measurement =  readings_queue[head].humidity_value;
  *seq = readings_queue[head].sequence_number;
  return true;
}

bool add_reading(short to, short reading_value){
  if(n_readings == READINGS_QUEUE_SIZE) {
    Serial.println("FATAL : sensor is losing samples due to insufficient space");
    return false;
  }
  readings_queue[tail].to = to;
  readings_queue[tail].humidity_value = reading_value;
  readings_queue[tail].sequence_number = global_seq_counter;
  global_seq_counter++;
  tail = (tail + 1) % READINGS_QUEUE_SIZE;
  n_readings++;
  return true;
}
 
void check_connection(){
    if(!mqttClient.connected())
    connectToMqttBroker();
}

void check_connection_and_publish(char* message){
    if(!mqttClient.connected()) //random disconnections are possible
      connectToMqttBroker();
    mqttClient.publish(MQTT_TOPIC,message);
    expecting_ACK = true; 
    Serial.println("Sent a DATA message to the broker");
}


void associate_to_PAN(){
  StaticJsonDocument<JSON_MSG_BUFFER_SIZE> doc;
  char msg[JSON_MSG_BUFFER_SIZE];

  doc["msg_type"] = 0;
  doc["mote_id"] = MOTE_ID;
  
  if(serializeJson(doc, msg,200)> sizeof(msg)){
    Serial.print("FATAL : msg size mismatch");
    return;
  }
  Serial.println("Sending ASSOCIATION MESSAGE to the PAN coordinator");
  mqttClient.publish(MQTT_TOPIC,msg);

  association_req_sent = true;
}

void setup() {
  Serial.begin(115200);

  pinMode(LED_PIN, OUTPUT); 
  pinMode(SLIDER_PIN, INPUT);
  WiFi.mode(WIFI_STA);
  WiFi.begin("Wokwi-GUEST","");
  
  Serial.println("Wifi ON");

  while (WiFi.status() != WL_CONNECTED) {
    delay(100); 
  } 

  mqttClient.setServer(MQTT_BROKER, MQTT_PORT);
  mqttClient.setBufferSize(2048);
  mqttClient.connect(MOTE_ID);

  while(!mqttClient.connected()){
    Serial.println("Attempting MQTT connection");
    delay(300);
    mqttClient.connect(MOTE_ID);
  }
  Serial.println("Connected to MQTT broker");
  mqttClient.subscribe(MQTT_TOPIC,0);
  mqttClient.setKeepAlive(60); //as long as it's more than the beacon interval it's ok
  mqttClient.setCallback(message_received);
  pinMode(CONNECTED_LED, OUTPUT); //setup connected pin
  dhtSensor.setup(DHT_PIN, DHTesp::DHT22);
  Serial.print(MOTE_ID);
  Serial.println(" online, waiting for a beacon to connect ");
 
}

/* main function that handles most of the logic*/

void message_received(char* topic, byte * message, unsigned int length) {
  StaticJsonDocument<JSON_MSG_BUFFER_SIZE> doc;
  DeserializationError error = deserializeJson(doc, message);
  // Test if parsing succeeds.
  if (error) {
    Serial.print(F("deserializeJson() failed: "));
    Serial.println((char*)message);
    Serial.println(error.f_str());
    return;
  }
  
  /*i received an ACK for the previous data message i sent,
  i move the head forwards and decrease the number of samples in the*/
  if(expecting_ACK && doc["msg_type"] == DATA_ACK_MESSAGE && doc["to"] == AID && doc["seq_number"] == last_unack_msg){
      Serial.print("Message [#");
      Serial.print(last_unack_msg);
      Serial.println("] has been acknowledged");

      expecting_ACK = false;
      head = (head + 1) % READINGS_QUEUE_SIZE; // move the head forward
      n_readings--;
      /*the head of the queue will be moved forward only after an ACK, this means that the same message
      will be retransmitted at each beacon until it's acked*/
      return;
   }
  if(doc["msg_type"] == BEACON_MESSAGE_TYPE)
    { 
      if(associated_to_PAN && doc["pan_id"] != pan_id){
        Serial.println("Hard disconnect detected, rebooting and reassociating");
        delay(1000);
        mqttClient.disconnect();
        ESP.restart();
      }
      expecting_beacon = false;
      unsigned int slot_duration = doc["slot_duration"];
      unsigned int time_until_cap = ((short)doc["cap_start"])*slot_duration;
      unsigned int beacon_interval =  doc["beacon_interval"];
      next_beacon_time_milli = millis() + beacon_interval* slot_duration;
      if(!associated_to_PAN){
            if(association_req_sent){ //check if it went ok, otherwise retry
                if(doc["AIDs"].containsKey(MOTE_ID))
                {
                  pan_id = doc["pan_id"];
                  Serial.print("Mote has AID : ");
                  AID = doc["AIDs"][MOTE_ID];
                  Serial.println(AID);
                  digitalWrite(CONNECTED_LED, HIGH);
                  associated_to_PAN = true;
                } else {
                  Serial.println("No AID found, sending association request again");
                  delay(time_until_cap);
                  next_beacon_time_milli -= time_until_cap;
                  associate_to_PAN(); 
                }
          } else {
            Serial.println("First beacon received, associating...");
            delay(time_until_cap); 
            next_beacon_time_milli -= time_until_cap;
            associate_to_PAN(); 
          }
         if(!associated_to_PAN)
            return; //no further actions when associating to the pan can be executed
      }
      Serial.print("Received beacon with sequence number : ");
      Serial.println((unsigned int) doc["beacon_seq_number"]);
      /* check if the actuators are connected */
      if(!act_1_aid && doc["AIDs"].containsKey(ACTUATOR_1))
      {       
        Serial.print("Detected Actuator 1 online, AID : ");
        act_1_aid = doc["AIDs"][ACTUATOR_1];
        Serial.println(act_1_aid);
      } 
      if(!act_2_aid && doc["AIDs"].containsKey(ACTUATOR_2))
      { 
        act_2_aid = doc["AIDs"][ACTUATOR_2];
        Serial.print("Detected Actuator 2 online, AID : ");
        Serial.println(act_2_aid);
      }
      //send frames if needed or check if there are frames destined to me
      unsigned short cap_start = doc["cap_start"],
      cap_duration = doc["cap_duration"];
      /*calculate how much time i need to wait until it is my turn in the CFP*/
      unsigned int time_until_CFP_up = 0,time_until_CFP_down = 0;
      JsonArray GTS_uplink = doc["GTS_uplink"];
      JsonArray GTS_downlink = doc["GTS_downlink"];
      unsigned int uplink_length = GTS_uplink.size();
      unsigned short my_turn_index = -1,ctr = 0;
      for(JsonVariant v : GTS_uplink) {
          if(v.as<short>() == AID) { 
            my_turn_index = ctr;
          }
          ctr++;
      }
 
      time_until_CFP_up = (cap_start + cap_duration + my_turn_index) * slot_duration;
      time_until_CFP_down = time_until_CFP_up + uplink_length*slot_duration;
      
      Serial.print("Time until CFP up and down : [");
      Serial.print(time_until_CFP_up);
      Serial.print(",");
      Serial.print(time_until_CFP_down);
      Serial.println("]");
      
      
      /*don't send new data messages until an ack has been received*/
      
      
      if(n_readings > 0 && (act_1_aid | act_2_aid)){ /*there is at least 1 measurement to send to the coordinator and 1 online actuator*/
            Serial.println("Sending measurement to PAN coordinator");
            StaticJsonDocument<JSON_MSG_BUFFER_SIZE> uplink; 
            char data_msg[200];
            unsigned short to,measurement; 
            unsigned long sequence_number;
            get_first(&to,&measurement,&sequence_number);
            uplink["msg_type"] = DATA_MESSAGE_TYPE;
            //if one of them is online this guarantees only that one will be chosen
            if(!act_1_aid || !act_2_aid)
              uplink["to"] = act_2_aid | act_1_aid;
            else 
              uplink["to"] = (to == 0 ? act_1_aid : act_2_aid);

            uplink["from"] = AID;
            uplink["value"] = measurement;
            last_unack_msg = sequence_number;
            uplink["sequence_number"] = sequence_number;
            serializeJson(uplink,data_msg,200); 
            Serial.print("Waiting for my CFP uplink slot :");
            Serial.println(time_until_CFP_up);
            delay(time_until_CFP_up);
            next_beacon_time_milli -= time_until_CFP_up;
            check_connection_and_publish(data_msg); 

           //expecting ACK next
      }
   
    }
 
}





void connectToMqttBroker()
{
  Serial.println("Reconnecting to MQTT Broker...");
  while (!mqttClient.connected())
  {
    if (mqttClient.connect(MOTE_ID))
    {
      Serial.println("Connected to MQTT broker.");
      // subscribe to topic
      mqttClient.subscribe(MQTT_TOPIC,0);
    }
    delay(100);
  }
}

#define BEACON_BUSY_WAIT_TOLERANCE 500
void sleep(){ 
  // WiFi.disconnect();
  // WiFi.mode(WIFI_OFF);
  long long wait_until = next_beacon_time_milli - millis() - BEACON_BUSY_WAIT_TOLERANCE ;

  if(wait_until < 0){ //beacon incoming
    return;
  }
  Serial.println("Going to sleep for the inactive part");
  //Serial.println(wait_until); 
  //esp_sleep_enable_timer_wakeup(next_beacon_time_milli* 1000);
  //esp_light_sleep_start();
  delay(wait_until);
  expecting_beacon = true;
  Serial.println("Woken up");
}

unsigned long ctr = 0;
unsigned long long random_n = 0;
unsigned int curr_slider_value = 0;
unsigned int curr_prob = 0;

void loop() {
  if(!associated_to_PAN){ //stay idle until the first beacon is received
    if(!mqttClient.connected())
      connectToMqttBroker();
    mqttClient.loop();
    delay(50);
  } else {
    if(!mqttClient.connected())
      connectToMqttBroker();
    mqttClient.loop(); 
    random_n = (esp_random() & 0x0FF ) % 100; 
    curr_slider_value = analogRead(SLIDER_PIN);
    curr_prob = map(curr_slider_value,0,4095,0,100);
    if(!expecting_beacon && !expecting_ACK){
      Serial.print("Current probability interval : [0,");
      Serial.print(curr_prob);
      Serial.println("]");
    }
    if(!expecting_beacon && !expecting_ACK && random_n < curr_prob /*&& (act_2_aid || act_1_aid)*/){
      Serial.print("[DATA COLLECTION] - Buffering measurement,value : ");
      unsigned int reading = dhtSensor.getTempAndHumidity().humidity;
      Serial.println(reading);
      add_reading((unsigned short) random_n & 1,reading);
    }
    if(expecting_beacon || expecting_ACK)
    { 
      delay(5);
      /*account for the time spent waiting + some overhead*/
      next_beacon_time_milli -= 5;
    }
    else 
      sleep();
    
  }
}

 
